a<-available.packages()
help()
install.packages("slidify")
license()
install.packages(c("slidify", "ggplot2", "devtools"))
utils:::menuInstallPkgs()
source("http://bioconductor.org/biocLite.R")
biocLite()
biocLite(c("GenomicFeatures", "AnnotationDbi"))
library(ggplot2)
search()
q()
install.packages("devtools")
library(devtools)
find_rtools()
q()
utils:::menuInstallPkgs()
library("KernSmooth")
q()
x <- l
x <- l
print(x)
msg <- "hello"
print msg
print(msg)
x <- 1:20
x
msg
pi
print(sqrt(2))
x <- list(1, "a", TRUE, 1+4i)
x
m <- matrix(l:6, nrow =2, ncol=3)
m <- matrix(1:6, nrow =2, ncol =3)
m
q()
x <- c("a", "b", "c", "d")
for (letter in x){
print(letter)
}
q()
x <- 3
print(x)
print x
x <- matrix(1:6,2,3)
print(x)
class(x)
for(i in seq_len(nrow(x))){}
add(3,4)
print(add(3,4))
add <- function(x,y){
x + y
}
print(add(3,4))
mydata <- rnorm(100)
sd(mydata)
sd(x=mydata)
sd(x=mydata, na.rm= FALSE)
lm(y~x, mydata, 1:100, model = FALSE)
args(lm)
plot(mydata)
mean
sd
lm <- function(x){x*x}
lm
search
search()
ls()
ls
x <- 1:10
x
if(x>5){x<-0}
cube <- function(x,n){x^3}
cube(3)
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <-10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
}
x <-5
y <- if(x < 3) {
NA
} else {
10
}
y
x <- list(a=1:5, b=norm(10))
x <- list(a = 1:5, b=rnorm(10))
lapply(x,mean)
x$a
x$b
rnorm(10)
x <- list(a =1:4, b=rnorm(10), c= rnorm(20:1), d= rnorm(100:1))
x
lapply(x,mean)
runif
runif(4)
rnorm()
rnorm
class rnorm
class rnorm()
type rnorm()
help()
str(rnorm)
str(apply)
x <- matrix(rnorm(200),20,10)
x
apply(x,2,mean)
apply(x,1,sum)
x <- c(rnorm(10), runif(10), rnorm(10,1))
x
x
x
f <- gl(3,10)
f
tapply(x,f,mean)
runif(5)
runif(1)
x <- rnorm(10)
x
f1 <- gl(2,5)
f1()
gl()
f2 <- gl(5,2)
f1
f2
interaction(f1,f2)
str(split(x,list(f1,f2)))
log(10)
log(-1)
## Assignment: Caching the Inverse of a Matrix
## 1. makeCacheMatrix :
##  This function creates a special "matrix" object that can cache its inverse.
## 2. cacheSolve:
##  This function computes the inverse of the special "matrix" returned by makeCacheMatrix above.
##  If the inverse has already been calculated (and the matrix has not changed),
##  then the cachesolve should retrieve the inverse from the cache.
## This function creates a "matrix" object which can cache its inverse
makeCacheMatrix <- function(x = matrix()) {
## Initialize s that is the Inverse of x
s <- NULL
set <- function(y) {
## the <<- operator which can be used to assign a value to an object in an environment
## that is different from the current environment
x <<- y
s <<- NULL
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## This function computes the inverse of the special "matrix"
## returned by makeCacheMatrix above.
cacheSolve <- function(x, ...) {
## x is a special matrix
s <- x$getsolve()
##  it checks to see if the inverse has already been calculated
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
## Return a matrix which is the inverse of 'x'
s
}
k<-makeCacheMatrix(x)
k$set(matrix(1:4,2,2))
k$get()
cacheSolve(k)
mtcars
tapply(mtcars$mpg, mtcars$cyl, mean)
26.66364 - 15.10000
apply(iris[, 1:4], 2, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
with(mtcars, tapply(mpg, cyl, mean))
sapply(mtcars, cyl, mean)
apply(iris[, 1:4], 2, mean)
iris
tapply(mtcars$cyl, mtcars$mpg, mean)
apply(mtcars, 2, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
setwd("D:\\R-programming\\getting-cleaning-data)
setwd("D:\\R-programming\\getting-cleaning-data")
source("quiz3-1.R")
install.packages("sqldf")
source("quiz3-1.R")
head(acs)
which(agricultureLogical)
class(agricultureLogical)
source("quiz3-2.R")
quantile(img.n,probs=c(0.3,0.8))
source("quiz3-3.R")
View(orderedData)
View(orderedData)
attributes(edu$CountryCode)
orderedData <- mergedData[order(mergedData$Gross.domestic.product.2012,decreasing=TRUE),]
str(mergedData)
source("quiz3-4.R")
mean(OECD, na.rm=TRUE)
mean(nonOECD, na.rm=TRUE)
source("quiz3-5.R")
source("quiz3-5.R")
install.packages("Hmisc")
source("quiz3-5.R")
View(orderResult)
str(result)
as.numeric(mergedData$Gross.domestic.product.2012)
orderResult <- result[order(result$Gross.domestic.product.2012),]
View(orderResult)
View(orderResult)
result = subset(mergedData, Income.Group == "Lower middle income")
View(result)
View(result)
attributes(mergedData$Income.Group)
setwd("D:\\R-programming\\getting-cleaning-data\\project")
source("run_analysis.R")
